var documenterSearchIndex = {"docs":
[{"location":"text/#Working-with-Text-Data","page":"Text","title":"Working with Text Data","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"We'll work with text data in many applications. We've included a few methods to help with text processing. ","category":"page"},{"location":"text/#VLDataScienceMachineLearningPackage.tokenize","page":"Text","title":"VLDataScienceMachineLearningPackage.tokenize","text":"function tokenize(s::String, tokens::Dict{String, Int64}; \n    pad::Int64 = 0, padleft::Bool = false, delim::Char = ' ') -> Array{Int64,1}\n\nArguments\n\ns::String - the string to tokenize.\ntokens::Dict{String, Int64} - a dictionary of tokens in alphabetical order (key: token, value: position) for the entire document.\npad::Int64 - (optional) the number of padding tokens to add to the end of the tokenized string. Default is 0.\npadleft::Bool - (optional) if true, the padding tokens are added to the beginning of the tokenized string. Default is false.\ndelim::Char - (optional) the delimiter used in the string. Default is ' '.\n\nReturns\n\nArray{Int64,1} - an array of integers representing the vectorized string.\n\n\n\n\n\n","category":"function"},{"location":"text/#VLDataScienceMachineLearningPackage.featurehashing","page":"Text","title":"VLDataScienceMachineLearningPackage.featurehashing","text":"function featurehashing(text::Array{String,1}; d::Int64 = 100, \n    algorithm::AbstractFeatureHashingAlgorithm = UnsignedFeatureHasing()) -> Array{Int64,1}\n\nComputes the feature hashing of the input text using the specified algorithm.\n\nArguments\n\ntext::Array{String,1} - an array of strings to be hashed.\nd::Int64 - (optional) the size of the hash table. Default is 100.\nalgorithm::AbstractFeatureHasingAlgorithm - (optional) the hashing algorithm to use. Default is UnsignedFeatureHasing.\n\nReturns\n\nArray{Int64,1} - an array of integers representing the hashed features.\n\n\n\n\n\nfunction featurehashing(text::Array{Int,1}; d::Int64 = 100, \n    algorithm::AbstractFeatureHashingAlgorithm = UnsignedFeatureHasing()) -> Array{Int64,1}\n\nComputes the feature hashing of the input text using the specified algorithm.\n\nArguments\n\ntext::Array{Int,1} - an array of integers to be hashed (e.g., tokenized text).\nd::Int64 - (optional) the size of the hash table. Default is 100.\nalgorithm::AbstractFeatureHasingAlgorithm - (optional) the hashing algorithm to use. Default is UnsignedFeatureHasing.\n\nReturns\n\nArray{Int64,1} - an array of integers representing the hashed features.\n\n\n\n\n\n","category":"function"},{"location":"wolfram/#Cellular-Automata","page":"Wolfram","title":"Cellular Automata","text":"","category":"section"},{"location":"wolfram/","page":"Wolfram","title":"Wolfram","text":"Cellular automata are discrete models studied in computational theory, mathematics, and theoretical biology. They consist of a grid of cells, each in one of a finite number of states, and evolve through simple rules based on the states of neighboring cells.","category":"page"},{"location":"wolfram/","page":"Wolfram","title":"Wolfram","text":"This is a fascinating area of study with applications in various fields, including physics, biology, and computer science. Here, we explore the Wolfram model of cellular automata, which provides a framework for understanding complex systems and emergent behavior.","category":"page"},{"location":"wolfram/#VLDataScienceMachineLearningPackage.simulate","page":"Wolfram","title":"VLDataScienceMachineLearningPackage.simulate","text":"function simulate(rulemodel::MyOneDimensionalElementaryWolframRuleModel, initial::Array{Int64,1};\n    steps::Int64 = 24, maxnumberofmoves::Union{Int64, Nothing} = nothing, \n    algorithm::AbstractWolframSimulationAlgorithm)) -> Dict{Int64, Array{Int64,2}}\n\nThe simulate function runs a Wolfram simulation based on the provided rule model and initial state.\n\nArguments\n\nrulemodel::MyOneDimensionalElementaryWolframRuleModel: The rule model to use for the simulation.\ninitial::Array{Int64,1}: The initial state of the simulation.\nsteps::Int64: The number of steps to simulate.\nmaxnumberofmoves::Union{Int64, Nothing}: The maximum number of moves to simulate.\nalgorithm::AbstractWolframSimulationAlgorithm: The algorithm to use for the simulation.\n\nReturns\n\nA dictionary mapping step numbers to the state of the simulation at that step.\n\n\n\n\n\n","category":"function"},{"location":"factory/#Factory-methods","page":"Factory","title":"Factory methods","text":"","category":"section"},{"location":"factory/","page":"Factory","title":"Factory","text":"We use a particular pattern to build and configure the various composite types in our system. This pattern involves the use of factory functions that encapsulate the construction logic for each type, ensuring that all necessary dependencies are properly initialized and configured.","category":"page"},{"location":"factory/#VLDataScienceMachineLearningPackage.build","page":"Factory","title":"VLDataScienceMachineLearningPackage.build","text":"function build(type::Type{MyAdjacencyRecombiningCommodityPriceTree}, data::NamedTuple) -> MyAdjacencyRecombiningCommodityPriceTree\n\nBuilds an MyAdjacencyRecombiningCommodityPriceTree model given the data in the NamedTuple.  This method builds the connectivity of the tree. To compute the price at each node, use the populate! method.\n\nArguments\n\ntype::Type{MyAdjacencyRecombiningCommodityPriceTree}: The type of the model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data NamedTuple must contain the following fields:\n\nh::Int64: The height of the tree.\nprice::Float64: The price at the root node.\nu::Float64: The price increase factor.\nd::Float64: The price decrease factor.\n\nReturns\n\nMyAdjacencyRecombiningCommodityPriceTree: the price tree model holding the computed price data.\n\n\n\n\n\nfunction build(modeltype::Type{MyOneDimensionalElementaryWolframRuleModel}, data::NamedTuple) -> MyOneDimensionalElementarWolframRuleModel\n\nThis build method constructs an instance of the MyOneDimensionalElementaryWolframRuleModel type using the data in a NamedTuple.\n\nArguments\n\nmodeltype::Type{MyOneDimensionalElementaryWolframRuleModel}: The type of model to build, in this case, the MyOneDimensionalElementaryWolframRuleModel type.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nindex::Int64: The index of the Wolfram rule\ncolors::Int64: The number of colors in the rule\nradius::Int64: The radius, i.e., the number of cells to consider in the rule\n\nReturn\n\nThis function returns a populated instance of the MyOneDimensionalElementaryWolframRuleModel type.\n\n\n\n\n\n","category":"function"},{"location":"factory/#VLDataScienceMachineLearningPackage.populate!","page":"Factory","title":"VLDataScienceMachineLearningPackage.populate!","text":"populate!(model::MyAdjacencyRecombiningCommodityPriceTree, price::Float64, Δ::Array{Float64,1})\n\nThis function populates the price tree model with the given price and price change factors. This method updates the model in place.\n\nArguments\n\nmodel::MyAdjacencyRecombiningCommodityPriceTree: The price tree model to populate.\nprice::Float64: The initial price to set at the root of the tree.\nΔ::Array{Float64,1}: The array of price change factors for each level of the tree.\n\n\n\n\n\n","category":"function"},{"location":".ipynb_checkpoints/index-checkpoint/#VLDataScienceMachineLearningPackage.jl","page":"VLDataScienceMachineLearningPackage.jl","title":"VLDataScienceMachineLearningPackage.jl","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"VLDataScienceMachineLearningPackage.jl","title":"VLDataScienceMachineLearningPackage.jl","text":"The VLDataScienceMachineLearningPackage.jl package is a Julia package that provides functions and types useful for data science, machine learning, and artificial intelligence applications. The package is designed to be simple and easy to use, and it is suitable for students, researchers, and practitioners in the data science and machine learning areas.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Installation","page":"VLDataScienceMachineLearningPackage.jl","title":"Installation","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"VLDataScienceMachineLearningPackage.jl","title":"VLDataScienceMachineLearningPackage.jl","text":"The package can be installed by running the following command in the Julia REPL:","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"VLDataScienceMachineLearningPackage.jl","title":"VLDataScienceMachineLearningPackage.jl","text":"using Pkg\nPkg.add(url=\"https://github.com/varnerlab/VLDataScienceMachineLearningPackage.jl.git\")","category":"page"},{"location":"data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"We've included several datasets in the package that we use for examples, activities, etc. ","category":"page"},{"location":"data/#VLDataScienceMachineLearningPackage.MyKaggleCustomerSpendingDataset","page":"Data","title":"VLDataScienceMachineLearningPackage.MyKaggleCustomerSpendingDataset","text":"MyKaggleCustomerSpendingDataset() -> DataFrame\n\nLoad the Kaggle customer spending dataset as a DataFrame.  The original dataset can be found at: Spending dataset.\n\n\n\n\n\n","category":"function"},{"location":"data/#VLDataScienceMachineLearningPackage.MyStringDecodeChallengeDataset","page":"Data","title":"VLDataScienceMachineLearningPackage.MyStringDecodeChallengeDataset","text":"MyStringDecodeChallengeDataset() -> NamedTuple\n\nLoad the String Decode Challenge testing and production datasets. \n\nReturn\n\nNamedTuple: A tuple containing the three datasets:\ntest_part_1: The first part of the test dataset.\ntest_part_2: The second part of the test dataset.\nproduction: The production dataset.\n\n\n\n\n\n","category":"function"},{"location":"data/#VLDataScienceMachineLearningPackage.MyCommonSurnameDataset","page":"Data","title":"VLDataScienceMachineLearningPackage.MyCommonSurnameDataset","text":"MyCommonSurnameDataset() -> DataFrame\n\nLoad the common surnames dataset by country as a DataFrame. The original dataset can be found at: Common Surnames by Country.\n\n\n\n\n\n","category":"function"},{"location":"data/#VLDataScienceMachineLearningPackage.MyCommonForenameDataset","page":"Data","title":"VLDataScienceMachineLearningPackage.MyCommonForenameDataset","text":"MyCommonForenameDataset() -> DataFrame\n\nLoad the common forenames dataset by country as a DataFrame. The original dataset can be found at: Common Forenames by Country.\n\n\n\n\n\n","category":"function"},{"location":"data/#VLDataScienceMachineLearningPackage.MySarcasmCorpus","page":"Data","title":"VLDataScienceMachineLearningPackage.MySarcasmCorpus","text":"function MySarcasmCorpus() -> MySarcasmRecordCorpusModel\n\nThe function corpus reads a file composed of JSON records and returns the data as a MySarcasmRecordCorpusModel instance. Each record in the file is expected to have the following fields:\n\nis_sarcastic::Bool - a boolean value indicating if the headline is sarcastic.\nheadline::String - the headline of the article.\narticle_link::String - the link to the article.\n\nReturns\n\nMySarcasmRecordCorpusModel - the data from the file as a MySarcasmRecordCorpusModel instance.\n\n\n\n\n\n","category":"function"},{"location":"data/#VLDataScienceMachineLearningPackage.MySMSSpamHamCorpus","page":"Data","title":"VLDataScienceMachineLearningPackage.MySMSSpamHamCorpus","text":"function MySMSSpamHamCorpus() -> MySMSSpamHamRecordCorpusModel\n\nThe function MySMSSpamHamCorpus reads the SMS Spam Ham dataset and returns the data as a MySMSSpamHamRecordCorpusModel instance.\n\n\n\n\n\n","category":"function"},{"location":"data/#VLDataScienceMachineLearningPackage.MyTrainingMarketDataSet","page":"Data","title":"VLDataScienceMachineLearningPackage.MyTrainingMarketDataSet","text":"MyTrainingMarketDataSet() -> Dict{String, DataFrame}\n\nLoad the components of the SP500 Daily open, high, low, close (OHLC) dataset as a dictionary of DataFrames. This data was provided by Polygon.io and covers the period from January 3, 2014, to December 31, 2024.\n\n\n\n\n\n","category":"function"},{"location":"#VLDataScienceMachineLearningPackage.jl","page":"Home","title":"VLDataScienceMachineLearningPackage.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The VLDataScienceMachineLearningPackage.jl package is a Julia package that provides functions and types useful for data science, machine learning, and artificial intelligence applications. The package is designed to be simple and easy to use, and it is suitable for students, researchers, and practitioners in the data science and machine learning areas.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/varnerlab/VLDataScienceMachineLearningPackage.jl.git\")","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"We'll work with may types in this package, including some abstract types that will be used to define the structure of our models.","category":"page"},{"location":"types/#VLDataScienceMachineLearningPackage.MySarcasmRecordModel","page":"Types","title":"VLDataScienceMachineLearningPackage.MySarcasmRecordModel","text":"MySarcasmRecordModel <: AbstractTextRecordModel\n\nModel for a record in the Sarcasm dataset.\n\nFields\n\ndata::Array{String, Any}: The data found in the record in the order they were found\n\n\n\n\n\n","category":"type"},{"location":"types/#VLDataScienceMachineLearningPackage.MySarcasmRecordCorpusModel","page":"Types","title":"VLDataScienceMachineLearningPackage.MySarcasmRecordCorpusModel","text":"MySarcasmRecordCorpusModel <: AbstractTextDocumentCorpusModel\n\nModel for a collection of records in the Sarcasm dataset.\n\nFields\n\nrecords::Dict{Int, MySarcasmRecordModel}: The records in the document (collection of records)\ntokens::Dict{String, Int64}: A dictionary of tokens in alphabetical order (key: token, value: position) for the entire document\n\n\n\n\n\n","category":"type"},{"location":"types/#VLDataScienceMachineLearningPackage.MySMSSpamHamRecordModel","page":"Types","title":"VLDataScienceMachineLearningPackage.MySMSSpamHamRecordModel","text":"MySMSSpamHamRecordModel <: AbstractTextRecordModel\n\nModel for a record in the SMS Spam Ham dataset.\n\nFields\n\nisspam::Bool - a boolean value indicating if the message is spam.\nmessage::String - the content of the SMS message.\n\n\n\n\n\n","category":"type"},{"location":"types/#VLDataScienceMachineLearningPackage.MySMSSpamHamRecordCorpusModel","page":"Types","title":"VLDataScienceMachineLearningPackage.MySMSSpamHamRecordCorpusModel","text":"MySMSSpamHamRecordCorpusModel <: AbstractTextDocumentCorpusModel\n\nModel for a collection of records in the SMS Spam Ham dataset.\n\nFields\n\nrecords::Dict{Int, MySMSSpamHamRecordModel}: The records in the document (collection of records)\ntokens::Dict{String, Int64}: A dictionary of tokens in alphabetical order (key: token, value: position) for the entire document\n\n\n\n\n\n","category":"type"},{"location":"types/#VLDataScienceMachineLearningPackage.MyAdjacencyRecombiningCommodityPriceTree","page":"Types","title":"VLDataScienceMachineLearningPackage.MyAdjacencyRecombiningCommodityPriceTree","text":"mutable struct  MyAdjacencyRecombiningCommodityPriceTree <: AbstractPriceTreeModel\n\nThe MyAdjacencyRecombiningCommodityPriceTree type is a model of a commodity price tree that uses an dictionary to store the price data. This model stores the connectivity information between nodes.\n\nFields\n\ndata::Union{Nothing, Dict{Int64,NamedTuple}}: A dictionary that stores the price data and path informationfor the tree.\nconnectivity::Dict{Int64,Array{Int64,1}}: A dictionary that stores the connectivity information between nodes.\n\n\n\n\n\n","category":"type"},{"location":"types/#VLDataScienceMachineLearningPackage.MyOneDimensionalElementaryWolframRuleModel","page":"Types","title":"VLDataScienceMachineLearningPackage.MyOneDimensionalElementaryWolframRuleModel","text":"mutable struct MyOneDimensionalElementaryWolframRuleModel <: AbstractRuleModel\n\nThe MyOneDimensionalElementarWolframRuleModel mutable struct represents a one-dimensional elementary Wolfram rule model.\n\nRequired fields\n\nindex::Int: The index of the rule\nradius::Int: The radius, i.e, the number of cells that influence the next state for this rule\nrule::Dict{Int,Int}: A dictionary that holds the rule where the key is the binary representation of the neighborhood and the value is the next state\n\n\n\n\n\n","category":"type"}]
}
